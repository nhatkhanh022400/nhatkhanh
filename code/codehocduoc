
*Ngày 3 đi thực tập : Cài đặt docker và mysql trên docker


// Cài docker
-link huong dan: https://www.youtube.com/watch?v=r6JiWwh-08c&t=487s

#code :
-apt update : update các gói dữ liệu
-apt install apt-transport-https ca-certificates curl software-properties-common
-curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
-add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
-apt update
-apt-cache policy docker-ce
-apt install docker-ce
-systemctl status docker
-service docker status
-service docker start
-service docker status
 
// Cài pull image có mysql
-docker pull mysql/mysql-server:5.7
-docker run --name=mysqlCon -p 3306:3306 -d mysql/mysql-server:5.7
-docker logs mysqlCon
-docker exec -it mysqlCon mysql -uroot -p
-ALTER USER 'root'@'localhost' IDENTIFIED BY 'nhatkhanh123';
-link huong dan : https://medium.com/@dilsimchandrasena/how-to-deploy-and-use-a-mysql-docker-container-in-ubuntu-4ace7c893982



*Ngày 4 đi thực tập : Import database vào mysql


#Chạy mysql
-docker start: chay docker
-docker ps: coi trong docker co nhung gi
-docker ps -a: coi tat ca nhung file da cai vao docker
-docker exec -it mysqlCon bash
-docker exec -it mysqlCon mysql -uroot -p

#Import database lên mysql
-cd /mnt/c/Users/P
-PC/     Public/
-docker cp /mnt/c/Users/PC/Downloads/crm-local-min.sql mysqlCon:/home: copy crm-local-min.sql đến mysqlCon:/home
-docker exec -it mysqlCon bash: mở server mysql
-mysql -uroot -p crm < /home/crm-local-min.sql: lấy crm-local-min trong home bỏ qua database crm
-docker exec -it mysqlCon mysql -uroot -p: vào thẳng mysql
-mysql -uroot -p: đăng nhập mysql 



code:
root@KhanhLapTop:~# docker cp C:\Users\PC\Downloads\crm-local-min.sql mysqlCon:/home
copying between containers is not supported
root@KhanhLapTop:~# cd /mnt/c/Users/P
PC/     Public/
root@KhanhLapTop:~# docker cp /mnt/c/Users/PC/Downloads/crm-local-min.sql mysqlCon:/home
root@KhanhLapTop:~# docker exec -it mysqlCon mysql -uroot -p
Enter password:
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)
root@KhanhLapTop:~# docker exec -it mysqlCon bash
bash-4.2# mysql -uroot -p crm < /home/crm-local-min.sql
Enter password:
bash-4.2# show crm;
bash: show: command not found
bash-4.2# mysql -uroot -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 76
Server version: 5.7.32 MySQL Community Server (GPL)

Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.



------------------Tuần 2 thực tập-------------------


*******Ngày 5 đi thực tập: Học về dockerfile********


*Bước 1: Thiết lập 
-Xác định các phụ thuộc ứng dụng.

-Tạo một thư mục cho dự án bằng lệnh :
    $ mkdir composetest
    $ cd composetest
-Tạo một tệp được gọi app.py trong thư mục dự án của bạn và dán tệp này vào: 
    $ touch app.py
-Sau đó cho dữ liệu vào app.py bằng lệnh:
    $ vim app.py
-Những dữ liệu thêm vào app.py
      import time

      import redis
      from flask import Flask

      app = Flask(__name__)
      cache = redis.Redis(host='redis', port=6379)

      def get_hit_count():
          retries = 5
          while True:
              try:
                  return cache.incr('hits')
              except redis.exceptions.ConnectionError as exc:
                  if retries == 0:
                     raise exc
                  retries -= 1
                  time.sleep(0.5)

      @app.route('/')
      def hello():
          count = get_hit_count()
          return 'Hello World! I have been seen {} times.\n'.format(count)   
-Tạo một tệp khác được gọi requirements.txt trong thư mục composetest và dán tệp này vào:  
      flask
      redis 


*Bước 2: Tạo Dockerfile

-Tạo thêm 1 tệp tên Dockerfile trong thư mục composetest:
  
  Trong tệp Dockerfile ta thêm dữ liệu:
    FROM python:3.7-alpine
    WORKDIR /code
    ENV FLASK_APP=app.py
    ENV FLASK_RUN_HOST=0.0.0.0
    RUN apk add --no-cache gcc musl-dev linux-headers
    COPY requirements.txt requirements.txt
    RUN pip install -r requirements.txt
    EXPOSE 5000
    COPY . .
    CMD ["flask", "run"]
  
  Các lệnh trên có nghĩa là
    Xây dựng hình ảnh bắt đầu bằng hình ảnh Python 3.7.
    Đặt thư mục làm việc thành /code.
    Đặt các biến môi trường được sử dụng bởi flasklệnh.
    Cài đặt gcc và các phụ thuộc khác
    Sao chép requirements.txtvà cài đặt các phụ thuộc Python.
    Thêm siêu dữ liệu vào hình ảnh để mô tả rằng vùng chứa đang lắng nghe trên cổng 5000
    Sao chép thư mục hiện tại .trong dự án vào workdir .trong hình ảnh.
    Đặt lệnh mặc định cho vùng chứa thành flask run.


*Bước 3: Xác định các dịch vụ trong tệp Soạn

-Tạo một tệp được gọi docker-compose.yml trong thư mục composetest và dán như sau:
    version: "3.4"
    services:
      web:
        build: .
        ports:
          - "5000:5000"
      redis:
        image: "redis:alpine"

    Các lệnh trên có nghĩa:
     version 3.4 Là ta chọn docker-compose phiên bản 3.4
     build . Là ta xây dựng trên docker-compose
     ports:
          - "5000:5000" : Là các webdịch vụ sử dụng một hình ảnh được xây dựng từ Dockerfiletrong thư mục hiện hành. Sau đó, nó liên kết vùng chứa và máy chủ 
                          với cổng tiếp xúc 5000
     image: "redis:alpine" Là các redis dịch vụ sử dụng một công Redis hình ảnh kéo từ registry Docker Hub.


*Bước 4: Xây dựng và chạy ứng dụng đã Soạn 

-Từ thư mục composetest, khởi động ứng dụng bằng cách chạy các lệnh 
     $docker-compose build
     $docker-compose up
-Sau đó lên trên 1 trình duyệt web gõ localhost:5000 nếu nó chạy ra    Hello World! I have been seen 1 times. thì ta thành công  
-Ngoài ra ta còn có thể gõ lệnh $docker image ls để kiểm tra các image đã cài trong docker


********Ngày 6 thực tập: Học về Docker symfony*********



-Tạo 1 thư mục tên symfony-docker
-Bên trong thư mục symfony-docker tạo thêm 3 thư mục build, mysql, symfony và tệp docker-compose.yml
 
 *Định cấu hình vùng chứa chi nginx:
 -Mở tệp docker-compose.yml sau đó mở tệp bằng lệnh vim docker-compose.yml và thêm vào trong tệp dữ liệu:
          version: '3'

          services:
            nginx:
                build:
                        context: .
                        dockerfile: Dockerfile-nginx
                volumes:
                        - ./symfony/:/var/www/symfony/
                ports:
                        - 8001:80
                networks:
                        - symfony
            networks:
          symfony:
  -dockerfile cho biết tệp cấu hình sẽ được sử dụng để tạo vùng chứa và chúng tôi sẽ tạo tiếp theo.
  -volumes sẽ thiết lập rằng thư mục cục bộ của chúng ta được gọi symfonysẽ được liên kết với /var/www/symfonythư mục của vùng chứa.
  -ports thực hiện ánh xạ giữa cổng 80 của vùng chứa và cổng 8001 mà chúng tôi sẽ sử dụng để truy cập thông qua trình duyệt.
  -Và cuối cùng là networksthiết lập một mạng lưới cho toàn bộ dự án để tất cả các container có thể giao tiếp với nhau.

-Tiếp theo,tạo tệp Dockerfile-nginx trong thư mục symfony-docker và thêm dữ liệu vào :
          FROM nginx:latest
          RUN rm -rf /etc/nginx/conf.d/default.conf
          COPY ./build/nginx/default.conf /etc/nginx/conf.d

          CMD [ "/bin/bash", "-c", "nginx -g 'daemon off;'" ]
        -Trong dòng 1 , xác định hình ảnh Nginx mà ta muốn sử dụng bằng cách sử dụng chỉ thị FROM.
        -Trong dòng 2, sử dụng COPY phương pháp để sao chép nội dung của default.conf tệp dự án (nơi cấu hình máy chủ mặc định mà Nginx sẽ sử dụng) nằm trong
         /etc/nginx/conf.d thư mục của vùng chứa.

-Trong thư mục build tạo thêm thư mục nginx, trong thư mục nginx tạo 1 tệp tên default.conf và cho dữ liệu vào:
        server {
        listen 80;
        root /var/www/symfony/public;

        location / {
            try_files $uri /index.php$is_args$args;
        }

         location ~ ^/index\.php(/|$) {
            fastcgi_pass php:9000;
            fastcgi_split_path_info ^(.+\.php)(/.*)$;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
            fastcgi_param DOCUMENT_ROOT $realpath_root;
            internal;
        }
        location ~ \.php$ {
            return 404;
        }
            error_log /dev/stdout info;
            access_log /var/log/nginx/project_access.log;
        }

-Chạy lệnh docker-compose up --build để set up Dockerfile-Nginx


*Định cấu hình vùng chứa cho PHP
- Mở tệp docker-compose.yml và thêm dữ liệu vào:
    version: '3'

    services:
        nginx:
                build:
                        context: .
                        dockerfile: Dockerfile-nginx
                volumes:
                        - ./symfony/:/var/www/symfony/
                ports:
                        - 8001:80
                networks:
                        - symfony
        php:
                build:
                        context: .
                        dockerfile: Dockerfile-php
                environment:
                        APP_ENV: dev
                        DATABASE_URL: mysql://root:root@mysql:3306/symfony_db?serverVersion=5.7
                volumes:
                        - ./symfony/:/var/www/symfony/
                networks:
                        - symfony
                depends_on:
                        - mysql
    
    networks:  
        symfony:

        -Bên trong, environmentchúng ta có thể khai báo các biến môi trường mà chúng ta muốn dự án Symfony của mình đọc và tải sau này.
        -networks cũng được tạo thành từ một phần tử duy nhất: symfonycho phép vùng chứa này và vùng chứa của Nginx giao tiếp.
        -Cuối cùng, volumescó cùng giá trị với vùng chứa Nginx, để symfonythư mục của dự án của chúng ta được liên kết với /var/www/symfonythư mục của vùng chứa.

-Tạo 1 tệp ở thư mục symfony-docker và thêm dữ liệu vào:
        FROM php:fpm-stretch

        RUN apt-get update && apt-get install -y

        RUN apt-get update && apt-get install -y --no-install-recommends \
              git \
              zlib1g-dev \
              libxml2-dev \
              libzip-dev \
        && docker-php-ext-install \
              zip \
              intl \
              mysqli \
              pdo pdo_mysql

        RUN curl -sS https://getcomposer.org/installer | php && mv composer.phar /usr/local/bin/composer
        COPY symfony/ /var/www/symfony
        WORKDIR /var/www/symfony/
- Chạy lệnh docker-compose up --build để set up Dockerfile-php


*Định cấu hình vùng chứa cho MySQL:

- Mở tệp docker-compose.yml và thêm dữ liệu:
    version: '3'

    services:
        nginx:
                build:
                        context: .
                        dockerfile: Dockerfile-nginx
                volumes:
                        - ./symfony/:/var/www/symfony/
                ports:
                        - 8001:80
                networks:
                        - symfony
        php:
                build:
                        context: .
                        dockerfile: Dockerfile-php
                environment:
                        APP_ENV: dev
                        DATABASE_URL: mysql://root:root@mysql:3306/symfony_db?serverVersion=5.7
                        empose:
                                - "8001"
                volumes:
                        - ./symfony/:/var/www/symfony/
                networks:
                        - symfony
                depends_on:
                        - mysql
        mysql:
                 image: mysql
                 command: ['--character-set-server=utf8mb4', '--collation-server=utf8mb4_unicode_ci', '--default-authentication-plugin=mysql_native_password']
                 environment:
                        MYSQL_DATABASE: symfony_db
                        MYSQL_USER: root
                        MYSQL_PASSWORD: nhatkhanh123
                        MYSQL_ROOT_PASSWORD: root
                 ports:
                        - 3066:3066
                 volumes:
                        - ./mysql:/var/lib/mysql
                 networks:
                        - symfony
    networks:
        symfony:

- Chạy lệnh docker-compose up --build để set up Dockerfile-mysql  




************Ngày 7 đi thực tập: Cài symfony**************

- Khởi chạy docker symfony php bằng lệnh docker exec -it  symfony-docker_php_1 bash
- Cài các source của symfony trong php container
        curl -sS https://get.symfony.com/cli/installer | bash
        mv /root/.symfony/bin/symfony /usr/local/bin/symfony
        symfony new symfony --dir=/var/www/symfony

- Sau khi cài xong chạy lệnh docker-compose up để chạy mysql, php, Nginx
- Check thử chạy thành công chưa bằng cách lên trình duyệt web gõ localhost:8001
- Để  thêm DATABASE_URLbiến môi trường vào cấu hình vùng chứa PHP ta vào php container và gõ lệnh bin/console doctrine:database:create





*************Ngày 8 đi thực tập: Ngồi ôn lại các kiến thức đã học ngoài ra còn tham khảo thêm các kiến thức về symfony ****************
        


----------------------------Tuần 3 thực tập-----------------------------


******************Ngày 9 đi thực tập: Tạo 1 docker symfony trong thư mục symfony*********************

- Tạo 1 repositories mới trên Github
- Cài đặt git trên window 
   link hướng dẫn: https://o7planning.org/vi/11707/huong-dan-cai-dat-va-cau-hinh-git-tren-windows
- Dùng git đưa dữ liệu trong symfony lên Github

        + Mở Git Bash để chạy lệnh
        + Đưa đường dẫn mặc định trên git bash về đúng đường dẫn thư mục đồ án
        + Gõ lệnh git init: Để khởi tạo thư mục cục bộ dưới dạng kho lưu trữ Git
        + Gõ lệnh git add . :Để thêm tệp vào kho lưu trữ cục bộ mới 
        + Gõ lệnh git commit -m "initial commit" : cam kết các tệp mà  đã sắp xếp trong kho lưu trữ của mình
        + Sao chép URL HTTPS của repository mới trên Github
        + Gõ lệnh git remove add origin remote repository URL
                  git remove -v 
                  Để trong dấu nhắc Lệnh, hãy thêm URL cho kho lưu trữ từ xa nơi kho lưu trữ cục bộ  sẽ được đẩy.
        + Gõ lệnh git push -f origin master: Để đẩy các thay đổi trong kho lưu trữ cục bộ lên GitHub.

- Tạo 1 thư mục mới tên symfony-project trong thư mục symfony-project copy hết thư mục symfony ở thư mực symfony-docker bỏ qua
- Trong thư mục symfony ta tạo 3 file docker-compose.yml, Dockerfile-php, Dockerfile-nginx
- Trong file docker-compose.yml ta gõ 
   
   version: '3'

   services:
        nginx:
                build:
                        context: .
                        dockerfile: Dockerfile-nginx
                volumes:
                        - ./:/var/www/symfony/
                ports:
                        - 8004:80
                networks:
                        - symfony
        php:
                build:
                        context: .
                        dockerfile: Dockerfile-php
                environment:
                        APP_ENV: dev
                        DATABASE_URL: mysql://root:root@mysql:3306/symfony_db?serverVersion=5.7 
                expose: 
                        - 8004
                volumes:
                        - ./:/var/www/symfony/
                networks:
                        - symfony
                depends_on:
                        - mysql          
        mysql:
                image: mysql

                command: ['--character-set-server=utf8mb4', '--collation-server=utf8mb4_unicode_ci', '--default-authentication-plugin=mysql_native_password']
                environment:
                        MYSQL_ROOT_PASSWORD: root
                ports:
                        - 3306:3306
                volumes:
                        - ./mysql:/var/lib/mysql
                networks:
                        - symfony  

   networks: 
        symfony:

- Trong file Dockerfile-php ta gõ 
        
        FROM nginx:latest
        RUN rm -rf /etc/nginx/conf.d/default.conf
        COPY ./build/nginx/default.conf /etc/nginx/conf.d/

        CMD [ "/bin/bash", "-c", "nginx -g 'daemon off;'" ]
- Trong file Dockerfile-nginx ta gõ
        FROM php:fpm-stretch

        RUN apt-get update && apt-get install -y

        RUN apt-get update && apt-get install -y --no-install-recommends \
                git \
                zlib1g-dev \
                libxml2-dev \
                libzip-dev \
             && docker-php-ext-install \
                zip \
                intl \
                mysqli \
                pdo pdo_mysql

        RUN curl -sS https://getcomposer.org/installer | php && mv composer.phar /usr/local/bin/composer
        COPY ./ /var/www/symfony
        WORKDIR /var/www/symfony/

- Sau đó gõ lệnh docker exec -it symfony_php_1 bash ta vô được trong phph sau đó gõ lệnh composer install để cài đặt  
- Cuối cùng gõ php bin/console cache:clear rồi lên ping thử trên trình duyệt web là localhost:8004 là xong



***************Ngày 10 đi thực tập: ****************

- Tạo 1 account trên bitbucket.org 
- Lấy source được cung cấp bỏ vào account bitbucket mới tạo 
- Vào powershell tạo 1 thư mục tên bitbucket
- Dùng lệnh git clone https://nhatkhanh022400@bitbucket.org/fimplus/hd-crmv2.git để kéo source trên bitbucket.org vào thư mục Bitbucket 
- Từ source vừa tạo ta vào thư mục hd-crmv2
- docker-compose up -d --build --force-recreate --no-deps mongo: Lệnh build lại 1 project
- Trong thư mục hd-crmv2 tạo 3 file tên docker-compose.yml, Dockerfile-php, Dockerfile-nginx
- Trong file docker-compose.yml ta gõ:
        version: '3'

        services: 
                nginx:
                        build: 
                                context: .
                                dockerfile: Dockerfile-nginx
                        volumes: 
                                - ./:/var/www/hd-crmv2/
                        ports: 
                                - 8080:80
                        networks: 
                                - symfony
                php:
                        build: 
                                context: .
                                dockerfile: Dockerfile-php
                        environment: 
                                APP_ENV: prod
                                DATABASE_URL: mysql://crm_sand:TZmtrsM5QEvngUKZ@mysql:3306/crm?serverVersion=5.7
                        expose: 
                                - 8080
                        volumes: 
                                - ./:/var/www/hd-crmv2/
                        networks: 
                                - symfony
                        depends_on: 
                                - mysql
                                - mongo
                mongo:
                        container_name: mongodb
                        image: mongo:3.4
                        environment:
                                - MONGO_INITDB_DATABASE=settings
                                #- MONGO_INITDB_ROOT_USERNAME=api_platform
                                #- MONGO_INITDB_ROOT_PASSWORD=123456
                        ports:
                                - "27017:27017"
                        volumes: 
                                - ./mongo:/var/lib/mongo
                        networks: 
                                - symfony 
                mysql:
                        image: mysql
                        command: ['--character-set-server=utf8mb4', '--collation-server=utf8mb4_unicode_ci','--default-authentication-plugin=mysql_native_password']
                        environment: 
                                MYSQL_DATABASE: crm
                                MYSQL_USER: crm_sand
                                MYSQL_PASSWORD: TZmtrsM5QEvngUKZ
                                MYSQL_ROOT_PASSWORD: ZH9rwW8s^\nP
                        ports: 
                                - 3306:3306
                        volumes: 
                                - ./mysql:/var/lib/mysql
                        networks: 
                                 - symfony  
        networks: 
                symfony:

- Trong thư mục Dockerfile-php ta gõ
        FROM php:7.1-fpm

        RUN apt-get update && apt-get install -y

        RUN apt-get update && apt-get install -y --no-install-recommends \
                git \
                zlib1g-dev \
                libxml2-dev \
                libzip-dev \  
                librabbitmq-dev \
                procps \
                vim \  
             && docker-php-ext-install \
                zip \
                intl \
                mysqli \
                pdo pdo_mysql\ 
                bcmath \
                sockets \
             && pecl install mongodb amqp \  
             && docker-php-ext-enable mongodb amqp \
             && usermod -u 1000 www-data

        RUN curl -sS https://getcomposer.org/installer | php && mv composer.phar /usr/local/bin/composer
        COPY ./ /var/www/hd-crmv2
        WORKDIR /var/www/hd-crmv2/

- Trong thư mục Dockerfile-nginx gõ:
        FROM nginx:latest
        COPY ./docker_build/nginx/nginx.conf /etc/nginx/nginx.conf
        COPY ./docker_build/nginx/default.conf /etc/nginx/conf.d/

- Dùng lệnh docker-compose up -d --build để build 4 container php, nginx, mysql, mongodb
 




*************************Ngày 11 đi thực tập: Tiếp tục công việc ngày hôm qua**************************


- Trong thư mục hd-crmv2 ta vào thư mục app/config/ và thêm vào 2 file mới do công ty cung cấp là local.php và parameters_local.php
- Sau đó ra lại thư mục hd-crmv2 gõ lệnh docker exec -it hd-crmv2_mysql_1 bash để vào mysql
- Sau khi đã vào mysql gõ lệnh mysql -ucrm -p để đăng nhập vào mysql 
- Khi đăng nhập thành công gõ lệnh SHOW DATABASES; để kiểm tra có những database ngoài
- Ta thấy có 2 database là crm với  information_schema
- Ta dùng lệnh use crm; để chọn crm databases để làm việc
- Lấy dữ liệu ở file crm-local-min.sql do công ty cung cấp
- Ta thoát khỏi mysql bằng lệnh exit
- Đến thư mục hd-crmv2 gõ lệnh cp /C:/Users/PC/Downloads/crm-local-min.sql hs-crmv2_mysql_1:/home để copy file crm-local-min.sql bỏ vào thư mục home trong mysql
- Vào lại mysql ta chọn databases crm 
- Gõ lệnh source < home/crm-local-min.sql để import file vào databases
- Sau khi import xong ta ra lại thư mục hd-crmv2
- Gõ lệnh docker exec -it hd-crmv2_php_1 bash để vào trong php 
- Mở this PC vào đường dẫn C:\Users\PC\Bitbucket\hd-crmv2\app\cache\prod\doctrine thêm vào thư mục orm do công ty cung cấp
- Vào php gõ lệnh compose install cho nó cài Đặt
- Sau khi cài đặt xong gõ lệnh php app/console cache:clear
- Rồi lên trình duyệt gõ localhost:8080 để check coi thử đã chạy chưa






**********************Ngày 12 đi thực tập: Tìm hiểu về Mautic Developer Documentation*************************

- Link tham khảo: https://developer.mautic.org/#introduction




*******************Ngày 13 đi thực tập: Chọn chủ đề đồ án**********************

- Quyết định chọn chủ đề: Ứng dụng Docker, Kubernetes và các nền tảng công nghệ của chiến lược Cloud Native
- Tham khảo 1 số tài liệu về chủ đề và làm đề cương đồ án
- Link tham khảo:       https://topdev.vn/blog/docker-la-gi/
                        https://topdev.vn/blog/docker-la-gi-kien-thuc-co-ban-ve-docker/
                        https://kubernetes.io/vi/docs/concepts/overview/what-is-kubernetes/
                        https://viblo.asia/p/phan-1-gioi-thieu-ve-kubernetes-924lJO6m5PM
                        https://renovacloud.com/5-nguyen-tac-kien-truc-cloud-native/
                        https://edwardthienhoang.wordpress.com/2020/05/17/tan-man-ve-cloud-native/
                        https://www.ods.vn/tin-cong-nghe/5-nguyen-tac-kien-truc-cloud-native-moi-developer-can-biet.html
                        https://topdev.vn/blog/tan-man-ve-cloud-native/
                        



-------------------------------Tuần 4 thực tập---------------------------------




******************Ngày 14 đi thực tập:Tìm hiểu Dockerfile, Docker image, Docker container có mối quan hệ thế nào************************

- Để tạo ra 1 docker container hoàn chỉnh ta cần làm các như sau
        + Tạo 1 thư mục chứ project đang làm
        + Tạo 1 Dockerfile bên trong có các lệnh như FROM,RUN, COPY, ADD,....
        + Sau khi tạo xong Dockerfile ta build docker image sử dụng các lệnh trong Dockerfile để tạo
        + Sau khi tạo Docker image xong ta khởi chạy docker bằng docker image vừa tạo ta sẽ được docker container của docker image đó
- Link tham khảo:
        https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
        https://cuongquach.com/tim-hieu-dockerfile-build-docker-image.html#Dockerfile_la_gi
        https://codelearn.io/sharing/docker-co-ban-cho-lap-trinh-vien
        https://blog.cloud365.vn/container/tim-hieu-docker-phan-4/
        https://blog.cloud-ace.vn/compute/thuc-hanh-co-ban-voi-docker-phan-3-dockerfile-tao-ra-images/
        https://www.youtube.com/watch?v=9Gf4vRYSkK8&t=929s
        https://www.youtube.com/watch?v=xtnyU3tg4Nk   

***********Ngày 15 thực tập: Tạo 1 Dockerfile và docker image**************

- Tạo 1 thư mục để chứa project cần làm
- Trong thư mục vừa tạo ta tạo 1 file tên Dockerfile
- Bên trong Dockerfile ta viết
        FROM ubuntu:latest
        RUN apt-get update 
        CMD echo "Hi"
- Sau đó chạy lệnh docker build ubuntu:16.04 . để build 1 image
- Kiểm tra coi image đã tạo thành công hay chưa thì ta dùng lệnh docker images
- Nếu muốn build Dockerfile đến thư mục khác ta dùng lệnh docker build ubuntu:16.04 + đường dẫn     
- Link tham khảo:
        https://kipalog.com/posts/Cac-lenh-trong-Dockerfile
        https://www.youtube.com/watch?v=9Gf4vRYSkK8&t=587s
        https://www.youtube.com/watch?v=tjyiUPvDFKY&t=126s
        

***************Ngày 16 thực tập: Tìm hiểu CI CD*****************

- CI là Continuous Integration. Nó là phương pháp phát triển phần mềm yêu cầu các thành viên của team tích hợp công việc của họ thường xuyên, mỗi ngày ít nhất 
  một lần.Mỗi tích hợp được "build" tự động (bao gồm cả test) nhằm phát hiện lỗi nhanh nhất có thể.   
- Một kịch bản CI bắt đầu bằng việc developer commit code lên repository (github chẳng hạn). Bất kỳ thay đổi nào cũng sẽ trigger một vòng đời CI. Các bước trong 
  một kịch bản CI thường như sau:

        Đầu tiên, developer commit code lên repo.
        CI server giám sát repo và kiểm tra xem liệu có thay đổi nào trên repo hay không (liên tục, chẳng hạn mỗi phút 1 lần)
        Ngay khi commit xảy ra, CI server phát hiện repo có thay đổi, nên nó nhận code mới nhất từ repo và sau đó build, chạy unit và integration test
        CI server sẽ sinh ra các feedback và gửi đến các member của project
        CI server tiếp tục chờ thay đổi ở repo   
- Lợi ích của CI 
        Giảm thiểu rủi ro nhờ việc phát hiện lỗi và fix sớm, tăng chất lượng phần mềm nhờ việc tự động test và inspect (đây cũng là một trong những lợi ích của CI, 
        code được inspect tự động dựa theo config đã cài đặt, đảm bảo coding style, chẳng hạn một function chỉ được dài không quá 10 dòng code ...)
        Giảm thiểu những quy trình thủ công lặp đi lặp lại (build css, js, migrate, test...), thay vì đó là build tự động, chạy test tự động
        Sinh ra phần mềm có thể deploy ở bất kì thời gian, địa điểm

- CD là Continuous Delivery. Nó hoạt động bằng cách triển khai tất cả thay đổi về code (đã được build và test) đến môi trường testing hoặc staging. Continuous 
  Delivery cho phép developer tự động hóa phần testing bên cạnh việc sử dụng unit test, kiểm tra phần mềm qua nhiều thước đo trước khi triển khai cho khách hàng 
  (production). Những bài test này bao gồm UI testing, load testing, integration testing, API testing... Nó tự động hoàn toàn quy trình release phần mềm.
- Continuous Delivery được thực hiện bằng cách sử dụng Deployment Pipeline
        Deployment Pipeline chia quy trình chuyển giao phần mềm thành các giai đoạn. Mỗi giai đoạn có mục tiêu xác minh chất lượng của các tính năng mới từ một góc 
        độ khác nhau để kiểm định chức năng và tránh lỗi ảnh hưởng đến người dùng. Pipeline sẽ cung cấp phản hồi cho nhóm trong việc cung cấp tính năng mới. Ở góc độ 
        trừu tượng hơn, deployment pipeline là quy trình để chuyển phần mềm từ version control đến tay người dùng. Mỗi thay đổi đến phần mềm sẽ đi qua một quy trình
        phức tạp để được phát hành.
        Bình thường sẽ có 5 giai đoạn: Delivery team, Version control, Build and Unit tests, Automated Acceptance tests, Release
- Vậy nếu kết hợp CI và CD lại ta sẽ được CI/CD là CI/CD là một bộ đôi công việc, bao gồm CI (Continuous Integration) và CD (Continuous Delivery), ý nói là quá trình
  tích hợp (integration) thường xuyên, nhanh chóng hơn khi code cũng như thường xuyên cập nhật phiên bản mới (delivery).
- Sau đây là Quy trình CI/CD thông thường
        + Bước 1: [Manual] Khởi tạo repository và có branch default là master và dev. Cài đặt trên Gitlab 9.
        + Bước 2: [Manual] Trừ owner ra, thì các coder sẽ push code tính năng lên branch dev
        + Bước 3: [Auto] Hệ thống tự động thực hiện test source code, nếu PASS thì sẽ deploy tự động (rsync) code lên server beta.
        + Bước 4: [Manual] Tester/QA sẽ vào hệ thống beta để làm UAT (User Acceptance Testing) và confirm là mọi thứ OK.
        + Bước 5: [Manual] Coder hoặc owner sẽ vào tạo Merge Request, và merge từ branch dev sang branch master.
        + Bước 6: [Manual] Owner sẽ accept merge request.
        + Bước 7: [Auto] Hệ thống sẽ tự động thực hiện test source code, nếu PASS sẽ enable tính năng cho phép deploy lên production server.
        + Bước 8: [Manual] Owner review là merge request OK, test OK. Tiến hành nhấn nút để deploy các thay đổi lên môi trường production.
        + Bước 9: [Manual] Tester/QA sẽ vào hệ thống production để làm UAT và confirm mọi thứ OK. Nếu không OK, Owner có thể nhấn nút Deploy phiên bản master trước 
                  đó để rollback hệ thống về trạng thái stable trước đó.
        + Bước 10: [Manual] Thắp nhang và hy vọng khách hàng không chửi rủa hoặc email complain.
- Trong quá trình CI/CD người ta thường dùng circle ci để build project và dùng gitlab để quản lý sourcecode
        Bản chất Circle CI là sử dụng docker, trong cấu hình Circle CI ta sẽ chỉ định các docker image sẽ sử dụng và các job, trong các job lại có các step, trong 
        các step là cụ thể các command. Ngoài ra còn có cấu hình filter giúp ta linh hoạt điều chỉnh sao cho chỉ run các job khi có merge/push vào 1 số branch nhất 
        định vân vân.    
        Về Gitlab không cần nói dài dòng, cũng như một hệ thống git thông thường (như github..), bạn có thể tìm hiểu thêm về git và Gitlab để team có thể cùng làm 
        việc và quản lý sourcecode trên Gitlab.    
- Mô tả quá trình run 1 job trên Circle CI:

        + Developer chỉ cần push hoặc merge vào 1 branch, Circle CI tự động biết event đó và khởi động lên job đã được cài đặt tương ứng.
        + Ban đầu Circle CI pull docker image về và run lên trên môi trường cloud của nó
        + Tiếp theo nó chạy các step đã được cài đặt trong docker container, thông thường step đầu tiên luôn là checkout tức là git checkout lấy source về (mặc định 
          lưu trong thư mục ~/project)
        + Các step tiếp theo được chạy tùy vào độ sáng tạo của bạn, ví dụ job để build thì thường là npm install rồi npm run abcxyz hay job để deploy thì có thể là 
          aws s3 sync hay serverless deploy...
        + Sau khi tất cả các step đã chạy xong, job kết thúc. Nếu exit code của job là error thì mặc định ta sẽ nhận được mail thông báo failed nữa.

- Những ưa điểm và nhược điểm của CI/CD
        + Ưa điểm:
                Tốc độ khai triển nhanh hơn 
                Kiểm tra và phân tích nhanh hơn
                Thay đổi mã nhỏ hơn
                Cách ly lỗi tốt hơn và nhanh hơn
                Tăng độ bao phủ mã
                Tự động triển khai để sản xuất 
                Không bao giờ gửi mã bị hỏng
                Quá trình được lặp lại
                Thời gian giải quyết nhanh hơn
                Backlog nhỏ hơn
                Cải thiện sự hài lòng của khách hàng
                Rất nhiều công cụ nguồn mở sẵn
        + Nhược điểm:
                Bộ kỹ năm mới nên yêu cầu các nhà phát triển phải học liên tục
                Quá trình tự động hóa không dễ một chút nào
                Đòi hổi nhà đầu tư trả trước đầu tư lớn 
                Các hệ thống kế thừa hiếm khi hỗ trợ CI/CD
                Mức độ đòi hỏi yêu cầu cao trong quá trình đảm bảo chất lượng 
- Link tham khảo:
        + https://topdev.vn/blog/trien-khai-ci-cd-voi-gitlab/
        + https://viblo.asia/p/ci-cd-va-devops-07LKXYXDZV4
        + https://kipalog.com/posts/Nhung-dieu-ban-can-biet-ve-mo-hinh-CI-CD-va-trien-khai-co-ban-voi-CircleCI
        + https://kipalog.com/posts/Gioi-thieu-CI-va-ap-dung-thuc-te-tool-Circle-CI 
        + https://viblo.asia/p/tim-hieu-ve-jenkins-va-cicd-eW65GbDxlDO  
        + https://timviec365.vn/blog/ci-cd-la-gi-new8173.html#uu-diem-cua-cicd-la-gi 



<<<<<<< HEAD
=======



>>>>>>> baibaocao
****************************Ngày 17 thực tập: Tạo 1 Github Pages bằng CI/CD***************************

- Tạo 1 githubpage bằng github
- Đầu tiên ta tạo thêm 1 repository trong github để chứa mã nguồn
- Tạo một file README để mô tả sơ qua về Repository 
- Tạo một file README để mô tả sơ qua về Repository của bạn.
- Tạo file “index.html”.
- Nhập nội dung file - vì file có phần mở rộng là html, nên nội dung file sẽ được viết bằng ngôn ngữ html.ở đây mới khởi đầu nên chỉ gõ hello world thôi.
- Sau khi làm xong nhấn vào setting trên thanh công cụ.
- Đổi tên repository thành định dạng như sau “any-name.github.io”. Trong bài viết này mình để là “huytm.github.io”.
- Kéo xuống một chút bạn sẽ thấy thông báo như sau là thành công rồi đó nếu nó hiện Your side is published at https://huytm.github.io/
- Truy cập url mà đã lấy được để xem thành quả github page sẽ hiện chữ hello world
- Link tham khaor:
        + https://blog.cloud365.vn/other/huong-dan-su-dung-Jekyll-Part1-Github-pages/









 

 ------------------------------------Tuần 5 thực tập---------------------------------------------













 **************************Ngày 18 đi thực tập: Tạo 1 website bằng hugo ********************************

 - Cài hugo bằng lệnh apt-get install hugo
 - Sau đó di chuyển đến thư mục cần làm ở đây mình làm trong thư mục staticweb với đường dẫn /githubpage/staticweb
 - Sau khi đã vào thư mục ta khởi chạy hugo bằng lệnh hugo new site quickstart 
 - Sau khi khởi chạy xong ta thấy hugo tạo ra thư mục quickstart bên trong thư mục staticweb
 - Vào thư mục quickstart bằng lệnh cd quickstart
 - Gõ lệnh git init để khởi tạo kho lưu trữ Git trong /root/githubpage/staticweb/quickstart/.git/
 - Tiếp theo gõ lệnh  git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke để clone source github vào
 - Gõ lệnh  echo 'theme = "ananke"' >> config.toml để  đưa các tài liểu vào file config.toml
 - Trong thư mục quickstart ta có 7 thư mục gồm : archetypes,content,data,layouts,resources,static,themes và 1 file config.toml
 - Gõ lệnh hugo new posts/my-first-post.md sẽ hiện đường dẫn /root/githubpage/staticweb/quickstart/content/posts/my-first-post.md created
 - Theo đường dẫn ta đến file my-first-post.md và bên trong file này ta gõ 
        title: "My Hugo"
        date: 2020-12-08T14:59:25+07:00
        draft: true
- Sau khi xong rồi ta khởi chạy hugo server để import lên localhost bằng lệnh hugo server -D
- Sau khi chạy sẽ có 1 bảng hiện lên
                           | EN  
        -------------------+-----
        Pages            | 10  
        Paginator pages  |  0  
        Non-page files   |  0  
        Static files     |  6  
        Processed images |  0  
        Aliases          |  1  
        Sitemaps         |  1  
        Cleaned          |  0  

        Built in 25 ms
        Watching for changes in /root/githubpage/staticweb/quickstart/{archetypes,content,data,layouts,static,themes}
        Watching for config changes in /root/githubpage/staticweb/quickstart/config.toml
        Environment: "development"
        Serving pages from memory
        Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender
        Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)
        Press Ctrl+C to stop
- Sau đó lên trình duyệt web gõ localhost:1313 ta ra được hugo ta vừa tạo
- Link tham khảo : https://gohugo.io/getting-started/quick-start/




*************************Ngày 19 đi thực tập: Import Hugo vừa tạo vào Github Pages****************************

- Tạo 1 repo trên github tên là nhatkhanh022400.github.io
- Vào thư mục vừa tạo hugo
- Trong thư mục này ta gõ lệnh git init: để khởi tạo git
- Gõ lệnh git remote add origin https://github.com/nhatkhanh022400/nhatkhanh022400.github.io.git: để liên kết repo nguồn tạo trên github với repo trên máy.
- Gõ lệnh git add . và git commit -m'update': để check lại những thứ trong hugo
- Gõ lệnh git push -u origin master : để push trên branch master
- Gõ lệnh git submodule add https://github.com/nhatkhanh022400/nhatkhanh022400.github.io public : để Submodule cho phép chúng ta nhúng một repo vào trong 
  repo chính của mình
- Giờ lên github ta sẽ thấy các dữ liệu trong hugo đã được chuyển lên branch master trong github
- Giờ ta tạo 1 thư mục bất kỳ rồi gõ lệnh git init và git clone https://github.com/nhatkhanh022400/nhatkhanh022400.github.io để kéo source treeb github về
- Vào trong thư mục nhatkhanh022400.github.io trong thư mục đó gõ code . để mở visual code
- Giờ ta gõ git branch -r để hiện tất cả các branch có trong github
- Gõ lệnh git checkout master để vào branch master
- Gõ lệnh git pull origin master --allow-unrelated-histories để  pull tất cả những gì có trong branch master lên branch origin main
- Lên lại github vào phần action tạo 1 github action tên hugo.yml
- Link tham khảo : https://lab.skywirex.com/dua-site-tao-boi-hugo-len-github-com/




<<<<<<< HEAD
=======
********************Ngày 20 đi thực tập: Từ Github build thành 1 Github Pages********************************

- Trong hugo.yml ta thêm các option sau:




name: github pages

on:
  push:
    branches:
      - main  # Set a branch name to trigger deployment

jobs:
  deploy:
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true  # Fetch Hugo themes (true OR recursive)
          fetch-depth: 0    # Fetch all history for .GitInfo and .Lastmod

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: '0.68.3'

      - name: Build
        run: hugo --minify

      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public


- Sau khi thêm hugo.yml ta vào setting kéo xuống phần github page chỉnh branch từ main thành gh-pages
- Sau đó lên trang web nhatkhanh.github.io để chạy thử github pages 
- Trong phần này có phát sinh nhiều lỗi như chọn không đúng branch để chạy hoặc để các file trong hugo không đúng branch cần làm dẫn đến khi khởi chạy github pages
  không được
- Lưu ý thêm trong hướng dẫn có nói về branch master nhưng những cái gì có về master phải chuyển thành main hết vì github giờ đã đổi tên master thành main




***************************Ngày 21 đi thực tập : Làm github pages trên local***************************



- Đầu tiên do đang ở quyền root nên ta nên ta chuyển về quyền user cho dễ thực hiện
- Sau khi ra quyền user ta thực hiện copy tất cả các thư mục đã làm trong root bỏ ra user bằng lệnh sudo cp -r /root/githubpage .
- Lệnh trên có nghĩa là copy tất cả thư mực githubpage trong root bỏ ra ngoài thư mục hiện đang đứng
- Sau khi copy xong gõ lệnh ls -l để kiểm tra quyền cấp phép ta thấy tất cả những gì copy ra từ githubpage vẫn đang ở quyền root
- Vì vậy ta cần phải chuyển từ quyền root sang quyền user để làm việc ở đây user tên là nhatkhanh@KhanhLapTop
- Ta chuyển từ root sang user bằng lệnh sudo chown -R nhatkhanh:nhatkhanh githubpage nếu không có -R thì chỉ mình githubpage được chuyển còn nếu thêm -R thì tất cả
  các file có trong githubpage đều được chuyển
- Sau ta truy cập vào thư mục dự án ở đây là thư mucj quickstart theo đường dẫn /home/nhatkhanh/githubpage/staticweb/quickstart
- Sau đó gõ lệnh hugo để build githubpages ta thấy nó hiện 1 bảng như sau:
                        | EN  
        -------------------+-----
        Pages            | 10  
        Paginator pages  |  0  
        Non-page files   |  0  
        Static files     |  6  
        Processed images |  0  
        Aliases          |  1  
        Sitemaps         |  1  
        Cleaned          |  0  

        Total in 41 ms
- Xuất hiện bảng này có nghĩa là nó đã build thành công nhưng trong github action có ghi là build trên thư mục nên ta cần gõ lệnh hugo -b file://$(pwd)/public để 
  build trong thư mục public
- Sau khi gõ xong nó sẽ hiện 1 bảng
                           | EN  
        -------------------+-----
          Pages            | 10  
          Paginator pages  |  0  
          Non-page files   |  0  
          Static files     |  6  
          Processed images |  0  
          Aliases          |  1  
          Sitemaps         |  1  
          Cleaned          |  0  

        Total in 41 ms
- Vậy là ta đã build thành công 1 githubpage
- Gõ code . để mở visual code
- Trong visual code gõ touch .gitignore để tạo file .gitignore
- Trong file .gitignore ta gõ public/
- Vào content/posts/my-first-post.md bổ sung thêm nội dung
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent semper purus elit, nec molestie purus sollicitudin et. Suspendisse in tortor eget metus 
        suscipit dignissim. Integer tincidunt mi mollis, scelerisque nisl non, ultrices justo. Vestibulum aliquam sem nulla, quis consequat est scelerisque a. 
        Vivamus at tincidunt leo. Sed et mattis magna. Maecenas suscipit, enim eget hendrerit imperdiet, mi risus elementum arcu, quis ornare felis ex vel erat.

        Etiam sit amet diam diam. Suspendisse potenti. Nulla ut tincidunt sem, id porta ante. Nam ligula nibh, tempor vel magna sed, dictum vehicula leo. Vivamus 
        viverra condimentum quam nec finibus. Fusce congue in nulla vitae finibus. Proin posuere tincidunt turpis, non mattis enim consectetur eu. In eget posuere 
        elit, vel tincidunt lectus. Sed nec porttitor turpis. Proin convallis volutpat elit eu sagittis. Nam nisl risus, euismod sit amet semper pretium, aliquam 
        vitae lorem. Vestibulum venenatis ultricies enim, bibendum rutrum lacus. Mauris leo quam, consectetur eget interdum ut, porta vitae felis. Cras nec dapibus 
        risus. Duis in finibus urna, at consequat elit.

        Morbi mollis feugiat eros in egestas. Nulla risus felis, porta vel dapibus eu, imperdiet a odio. Praesent posuere enim id nunc commodo iaculis. Nunc auctor
        nisl ut tellus pharetra, eu molestie sapien laoreet. Pellentesque convallis in nisi eget finibus. Nullam et arcu vel erat imperdiet accumsan id hendrerit 
        libero. Donec non dui laoreet, fermentum quam finibus, convallis tortor. Quisque dignissim non lectus tincidunt pharetra. Duis ullamcorper vulputate elementum.

        Nullam in sapien placerat, accumsan magna tincidunt, vehicula metus. Aliquam fermentum vel ipsum nec pharetra. Maecenas vestibulum sed lorem quis hendrerit. 
        Mauris laoreet dolor quis erat sollicitudin consequat. Cras pulvinar ornare erat, sed efficitur arcu. Pellentesque tincidunt hendrerit nisl sed egestas. 
        Donec non leo a ligula consectetur lacinia ut nec lectus. Donec et lorem mattis nisi laoreet bibendum et sed ligula. Nam ac nibh id arcu placerat scelerisque 
        at sit amet metus. Mauris lobortis mauris lectus, ornare venenatis arcu lobortis ac.

        Etiam lacinia purus sit amet nisl pellentesque congue. Ut libero elit, pulvinar et risus a, porta laoreet purus. Nullam dolor tortor, tempus imperdiet nisl 
        non, pharetra hendrerit felis. Vestibulum ut mattis dui. Integer eget urna id sem laoreet aliquet non nec neque. Duis non vestibulum risus. Nulla in lectus 
        in quam semper iaculis in sit amet urna. Vestibulum venenatis tellus ut nisi semper, non tincidunt quam laoreet. Integer in est ullamcorper, mattis velit sed, 
        facilisis turpis. Pellentesque venenatis ante ut faucibus auctor. Duis a urna id ex facilisis interdum eget quis lorem. Sed mi massa, semper vel faucibus id
        molestie vitae dui. Mauris fermentum sit amet urna nec molestie. Morbi nec nunc quis mauris ultrices pulvinar vitae eget nunc. Mauris ullamcorper nunc eget 
        dolor tristique pretium.

- Lệnh git reset --hard là reset những cài đặt git lại
- Sau khi làm xong gõ lệnh hugo -b file://$(pwd)/public để build lại những sửa chữa
- Sau đó gõ git status coi những thay đổi
- Gõ git add đường dẫn thay đổi
- Gõ git commit -m'tên muốn đặt cho thay đổi'
- Gõ git push để đưa lên github
- Lệnh git push origin -d tên branch giúp xóa 1 branch bất kỳ trên github
- Lên trình duyệt gõ nhatkhanh022400.github.io để thấy những thay đổi được update lên githubpage









>>>>>>> baibaocao


 - 







<<<<<<< HEAD
=======
            


        
                              
                            






>>>>>>> baibaocao
            




----------------------------------------- Tuần 6 thực tập ---------------------------------------------








********************************Ngày 22 + 23 + 24 thực tập : Viết báo cáo về quá trình CI/CD ngoài thực tế****************************************
 



_____________________________________________BÀI BÁO CÁO VỀ CI/CD NGOÀI THỰC TẾ _____________________________________________________




* Nguồn gốc CI/CD :
        
        Ngày xửa ngày xưa,ở thung lũng độn silicon valley, có 2 anh em cùng cha khác bố. Người anh tên Developer, làm ngồi coding. Người em tên IT Operation, làm nghề
        quản trị hệ thống CNTT. Cả 2 anh em đều phục vụ 1 cô bé tên User. Hằng ngày nàng sử dụng những application do anh Developer tạo ra, được deploy và vận hành bởi
        chàng IT Operation
        Rồi thời gian cứ thế trôi qua, nàng User từ cô bé ngây thơ ngày nào đã trở thành thiếu nữ căng đầy sức sống. Càng lớn ham muốn của nàng càng cao, nàng muốn 
        application phải nhiều tính năng hơn nữa. Trước đây, một tuần nàng chỉ đòi hỏi change requirement một lần, giờ thì ngày nào cũng muốn. Đôi khi ngày muốn đến 2,3
        lần, thậm chí sáng đòi thêm feature này, chiều lại đòi bỏ đi. Làm 2 chàng Developer và IT Operation làm việc không biết ngày đêm nhưng release vẫn bị trễ. Nên 
        rồi 2 chàng phải cầu cứu lấy bụt khi bụt nghe xong ông giải thích. Trong phát triển phần mềm, anh Developer thì chỉ tập trung ngồi viết code. Nhưng để ứng dụng 
        chạy được cần phải có môi trường, server, infrastructure.Cho nên cần có IT Operation để deploy vận hành ứng dụng. Anh Developer chỉ biết code, anh IT Operaton chỉ 
        biết vận hành nên giữa 2 con luôn có 1 bức tường ngăn cách gọi là Wall of Confusion, làm delay quá trình release sản phẩm. Chưa kể mỗi lần Developer thêm tính năng 
        mới lại phải deploy lại 
        Cho nên nếu 2 người có thể hợp lại thành một, thì dù có yếu khi kết hợp sẽ trở nên mạnh như hổ. Hai con mỗi người có 1 skill riêng, nếu làm việc đơn lẻ sẽ không 
        phục vụ nổi nàng User, nhưng nếu 2 con kết hợp lại với nhau thì những nhu cầu của nàng User đều có thể đáp ứng được. Khi kết hợp với nhau, các con sẽ tạo nên mô
        hình gọi là CI/CD, khiến việc deploy ứng dụng nhanh chóng, liên tục, đảm bảo thỏa mãn nàng User

* Khái niệm CI/CD : 

- CI là Continuous Integration. Nó là phương pháp phát triển phần mềm yêu cầu các thành viên của team tích hợp công việc của họ thường xuyên, mỗi ngày ít nhất một lần. 
  Mỗi tích hợp được "build" tự động (bao gồm cả test) nhằm phát hiện lỗi nhanh nhất có thể. Cả team nhận thấy rằng cách tiếp cận này giảm thiểu vấn đề tích hợp và cho 
  phép phát triển phần mềm nhanh hơn.
- CD ở đây ta có 2 khái niệm là Continuous Delivery và Continuous Deployment
        + Continuous Delivery bằng cách triển khai tất cả thay đổi về code (đã được build và test) đến môi trường testing hoặc staging. Continuous Delivery cho phép 
          developer tự động hóa phần testing bên cạnh việc sử dụng unit test, kiểm tra phần mềm qua nhiều thước đo trước khi triển khai cho khách hàng (production)
        + Continuous Deployment (cũng viết tắt là CD ) lại là kỹ thuật để triển khai code lên môi trường production một cách tự động, và cũng nên là mục tiêu của hầu
          hết công ty.
- Vậy khi kết hợp 2 khái niệm này lại ta được 1 khái niệm CI/CD là là quá trình tích hợp (integration) thường xuyên, nhanh chóng hơn khi code cũng như thường xuyên 
 cập nhật phiên bản mới (delivery).

* Các giai đoạn của CI/CD :

- Các giai đoạn của CI/CD gồm : Những yêu cầu được đề ra => xây dựng => kiểm tra => khai triển 
- Ngoài ra giai đoạn CI/CD còn chạy liên tục vì vậy khi các developer có thể cập nhật liên tục trong khi lưu trữ ban đầu còn các bước tiếp theo sẽ được thực hiện tự 
  động hóa. Nhờ sự tự động hóa, chu trình chuyển từ giai đoạn này sang giai đoạn khác được cập nhật liên tục

* Quá trình CI/CD, cần có các thành phần :

- Nơi chứa source code của developer có thể là các phần mềm như: github,gitlab,bỉbucket,....
- Tiến hành testing phần mềm: chạy các unit test cũng như các thông số quét mã nguồn để tìm các lỗi bảo mật lỗi code lặp lại,....
- Môi trường build sản phẩm: là môi trường khi ra đời một sản phẩm phần mềm,sanr phẩm đó chạy trên môi trường đó, ví dụ như Window, MacOS, Linux,...
- Môi trường triển khai sản phẩm
        + Môi trường develop: môi trường dành cho nhà phát triển
        + Môi trường qc: Môi trường dành cho bộ phận kiểm thử phần mềm 
        + Môi trường staging: Môi trường dành cho khách hàng, người thuê viết phần mềm
        + Môi trường production: Môi trường dành cho cộng đồng người dùng

* Lợi ích của CI/CD:
- Sự thay đổi code nhỏ:
        + Một lợi ích vô cùng lớn của CI/CD là nó cho phép bạn tích hợp các đoạn code nhỏ cùng một lúc. Những thay đổi code này đơn giản và dễ sử dụng hơn so với những 
          đoạn code khổng lồ. Do đó, có ít vấn đề cân sửa chữa, thay đổi sau này 
        + Những sự thay đổi nhỏ này có thể được kiểm tra ngay khi chúng được tích hợp vào kho code. Từ đó cho phép các developers nhận ra một vấn đê trước khi có quá 
          nhiều việc được hoàn thành sau đó. Điều này thực sự hiểu quả đối với các nhóm phát triển, những người làm việc từ xã cũng như những người làm việc nội bộ vì 
          giao tiếp giữa các thành viên trong nhóm có thể khó khăn.
- Cô lập lỗi hiệu quả:
        + Cô lập lỗi đề cập đến việc thiết kê hệ thống sao cho khi lỗi xảy ra, các kết quả tiêu cực bị giới hạn trong một phạm vi nhất định. Việc hạn chế phạm vi của các
          vấn đề làm giảm khả năng hư hỏng và giúp hệ thống dễ bảo trì hơn 
        + Thiết kế hệ thống của bạn với CI/CD đảm bảo rằng việc cách ly lỗi được phát hiện nhanh hơn và dễ thực hiện hơn. Do đó, hậu quả của lỗi xuất hiện trong ứng dụng
          được giới hạn phạm vi
- Kiểm tra có độ tin cậy cao: 
        + Sử dụng CI/CD giúp độ tin cậy của quá trình kiểm tra được cải thiện. Từ đó cho phép tiến hành các kiểm tra chính xác hơn. Độ tin cây kiểm tra trong CI/CD được 
          coi là liên turpis
- Khả năng tự giải quyết các lỗi nhỏ:
        + Việc kết hợp liên tục tích hợp, liên tục triển khai, liên tục phân phối vào quy trình phát triển tổ chức của bạn làm giảm số lượng các khuyết điểm nhỏ trong 
          công việc tồn đọng của bạn. Những lỗi nhỏ này được phát hiện trước khi sản xuất và chỉnh sửa trước khi đưa ra thị trường cho người dùng cuối
        + Lợi ích của việc giải quyết các lỗi trước thời hạn là rất nhiều. Ví dụ : các developers sẽ có nhiều thời gian hơn để tập trung vào các vấn đề lớn. Có nhiều thời
          gian để cải thiện hệ thống, có thể tìm ra các vấn đề lớn hơn trước khi phát hành. Một lợi ích khác là giữ cho khách hàng của bạn hài lòng bằng cách ngăn họ phát 
          hiện ra lỗi trong sản phẩm của bạn
- Tăng tính minh bạch và trách nhiệm của nhóm :
        + CI/CD là một cách tuyệt vời để nhận được phản hồi liên tục không chỉ từ khách hàng mà còn từ nhóm của bạn. Điều này làm tăng tính minh bạch của mọi vấn đề
          trong nhóm và khuyến khích trách nhiệm giải trình có trách nhiệm
        + Cả CI và CD đều cung cấp phản hồi nhanh chóng, cho phép bạn cải thiện đều đặn và liên tục sản phẩm của mình
- Giảm chi phí : Tự động hóa trong đường dẫn CI/CD làm giảm số lượng lỗi có thể xảy ra trong nhiều bước lặp đi lặp lại của CI và CD. Việc này cũng giải phóng thời gian 
                 của developer có thể dành cho việc phát triển sản phẩm. Từ đó giẩm chi phí sửa lỗi 
- Bảo trì và cập nhật dễ  dàng :
        + Bảo trì và cập nhật là một phần quan trọng để tạo ra sản phẩm tuyệt vời. Điểm đặc biệt trong quá trình CI/CD là thực hiện bảo trì trong khoảng thời gian ngừng
          hoạt động. Chúng ta còn có thể hiểu đó là thời gian không quan trọng. Điều này sẽ không ảnh hưởng tới hoạt động của hệ thống trong giờ cao điểm
        +                  

* CI/CD được áp dụng vào thực tế ở đây là ở doanh nghiệp :


- Như những gì bữa giờ được thực hành làm ta cos thể tạo được 1 githubpage trên server nhưng trong thực tế việc áp dụng CI/CD vào doanh nghiệp nó rất khác biệt
- Thông thường khi 1 doanh nghiệp áp dụng CI/CD vào 1 dự áp của họ ta thường thấy có 6 bước 
        + Lint code
        + Build image
        + Test code
        + Push image
        + Continuous Delivery
        + Continuous Deployment
- Ngoài 6 bước này ta vẫn có thể thêm các bước khác vào do trong quá trình làm có nhiều phát sinh        
- Đầu tiên là về Lint code ta hiểu đơn giản đây là quá trình mà thành viên trong dự án có thể làm code của mình sau đó add code và commit nó lên branch của 
  repositories team(ở đây có thể đưa lên github,gitlab,bitbucket.....)
- Sau khi commit lên repository rồi ta sẽ đóng gói các source code của từng thành viên để tiến hành test code quá trình này gọi là build images
- Tiếp theo là Test code đúng với tên gọi của mình đây là 1 quá trình kiểm tra thử coi những source code được commit lên có vấn đề gì không
        + Những vẫn đề có thể phát sinh trong lúc các thành viên commit lên git repo như
        ~ Vấn đề đầu tiên team gặp phải là conflict code. Team dành nhiều thời gian để giải quyết các conflict giữa việc đẩy code của các thành viên làm như thế nào 
          cho code chạy đủ
        ~ Thứ hai, sự khác biệt giữa các môi trường từ production, staging, test, dev khác nhau một trời một vực.  Người thì dùng hệ điều hành Linux, Ubuntu, người 
          thì lại dùng Window với Mac khi đưa code lên thì rất loạn.
        + Ngoài ra ta cũng kiểm tra thử code chạy có được như ý muốn không có nhiều trường hợp test code kiểm tra không thấy lỗi những khi chạy lại cho 1 kết quả 
          không như mong muốn
        + Nêu ta input vào source code 1 phép tính đơn giản như 1 + 1 thì chắc chắn kết quả output trả ra bằng 2 thì mới được coi là quá trình test code thành công
        + Trong quá trình test code CI server sẽ gửi các feedback lại cho các developer để họ có thể biết được những gì đang diễn ra
        + Nếu trong quá trình test xảy ra lỗi thì developer phải fix lỗi 
- Test code gồm có 3 quá trình:        
        + Đầu tiên unit test. Đây là phần test được chạy đầu tiên, thường là bởi các lập trình viên, dùng để test các function hoặc class. Khi những function hoặc 
          class này cần truy cập đến các tài nguyên bên ngoài, thì những tài nguyên đó thường được fake như là các “mock” hay “stub”.
        + Tiếp theo là Integration testsl à bước tiếp theo từ unit tests. Integration tests đảm bảo các module tạo nên ứng dụng hoạt động mượt mà với nhau. Lý tưởng
          nhất là integration tests được chạy trong môi trường tương tự với môi trường production. 
        + Sau cùng là System tests. Test toàn bộ hệ thống trong một môi trường càng giống với môi trường production càng tốt. 
- Ngoài việc có một bộ tests chất lượng, thì môi trường chúng chạy trên đó cũng quan trọng không kém. Những yếu tố sau đây là rất cần thiết:
        + Môi trường sạch sẽ. Sạch sẽ ở đây nghĩa là môi trường được reset trước mỗi lần chạy test để đảm bảo các lần test không ảnh hưởng lẫn nhau. Các công nghệ như
          virtual machine hay snapshot có thể giúp thực hiện điều này.
        + Môi trường tương đồng. Môi trường chạy test phải gần giống với môi trường production.
        + Trường hợp lý tưởng thì môi trường có thể được tạo lập và huỷ bỏ nhanh chóng theo yêu cầu. Đưa những môi trường chạy code lên Cloud là một ý tưởng hay trong 
          trường hợp này.      
- Sau khi đóng gói và test code tất cả những source code cần thêm vào ta sẽ đẩy những source đó lên môi trường production bước này được gọi là push image
- Sau khi đã đưa lên việc tiếp theo sẽ là deploy những source code vừa đưa lên đó
- Để deploy được ta thực 2 bước là Continuous Delivery và Continuous Deployment, hai bước này chính là CD
        + Đầu tiên là về Continuous Delivery tập quán của việc đảm bảo code của từng lập trình viên tham gia vào dự án có thể deploy ở bất cứ thời điểm nào. Tuy 
          nhiên điều này không có nghĩa là nó có thể đảm bảo ứng dụng có thể được deploy một cách an toàn trên môi trường production vì thông thường sẽ có sự khác 
          biệt trong cách cấu hình ứng dụng giữa môi trường production và test
        + Ở đây có thể  hiểu là Coutinuous Delivery là tích hợp tất cả những gì thay đổi vào production và luôn ở tình trạng sẵn sàng để deploy
        + Tiếp theo là Continuous Deployment là  giúp việc deploy ứng dụng có thể được diễn ra trong bất cứ thời điểm nào và sau đó thậm chí là tự động release một
          phiên bản mới trên môi trường test hoặc production nếu như bản build (gồm các mã lệnh được bạn gửi lên server) của bạn vượt qua được tất cả các test case.
        + Ở đây có thể hiểu là bước tiếp theo của Continuous Delivery là deploy luôn vào production
- Khi production đã hoàn thiện, tiếp theo là giai đoạn triển khai thực tế. Việc kiểm tra sản phẩm sẽ không dừng lại ở giai đoạn này. Chúng ta vẫn sẽ nhận được thông 
  báo lỗi ở bất kỳ giai đoạn nào qua DevOps pipeline cho đến khi nó được xử lý đúng
- Trong môi trường sản xuất, khi sản phẩm được chuyển giao và triển khai thành công. Tiếp theo bắt đầu quy trình cải tiến sản phẩm theo nhu cầu người dùng.
- Để đảm bảo sản phẩm hoạt động ổn định và thu thập thông tin hữu ích để cải tiến, chúng tôi tiếp tục theo dõi, gửi phản hồi vào DevOps pipeline.
- Chính vòng lặp vô hạn này đã mang đến cho DevOps sự trực quan vô hạn

* Các công cụ CI/CD thông dụng :
        
        + Jenkins
                ~ Nhắc tới DevOps chắc chắn sẽ luôn đề cập đến Jenkins. Là một phần mềm tự động hóa, Jenkins cung cấp cho người dùng một công cụ mạnh mẽ để xây dựng,
                  thử nghiệm và triển khai sản phẩm. Công cụ nguồn mở này còn có nhiều tiện ích bổ trợ để lựa chọn, làm cho nó dễ dàng phù hợp với hầu hết mọi hoạt động.
                ~ Ở đây chúng ta đang tập trung vào các dự án mã nguồn mở, nên sẽ phải nhắc đến Jenkins với sự hỗ trợ từ Apache Maven. Một công cụ quản lý dự án được 
                  sử dụng nhiều bởi Java developer.
                ~ Với sự hậu thuẫn từ các đại gia công nghệ như Microsoft, Redhat (hiện thuộc sở hữu của IBM) và CloudBees, Jenkins là một công cụ hữu ích hàng đầu 
                  cho cộng đồng mã nguồn mở và hiện đang được sử dụng miễn phí.
        + CircleCI
                ~ Công cụ CI này giúp người dùng quản lý mã của họ từ thời điểm bắt đầu đến khi kết thúc trong nhiều môi trường khác nhau. CircleCI cho phép các developer 
                  tạo ra Workflows để kiểm soát tốt hơn pipeline của họ. Cùng với tích hợp VCS, kiểm tra tự động và thông báo khi xây dựng bị lỗi.
                ~ Với các tùy chọn cho SaaS hoặc tự lưu trữ on-prem, CircleCI cung cấp một giải pháp mạnh mẽ giúp tự động hóa DevOps pipeline của bạn. Tính năng Orbs 
                  cùng với các nhà cung cấp dịch vụ thứ 3 cũng được ra mắt. Để đơn giản hóa quá trình tích hợp các dịch vụ bổ sung như giám sát các lỗ hổng nguồn mở
        + Travis CI
                ~ Dịch vụ CI phổ biến này được xây dựng dành cho người dùng GitHub. Được yêu thích để phục vụ cho việc thử nghiệm các dự án nguồn mở trở thành cinch. 
                  Travis CI giúp dễ dàng kiểm soát testing các pull request. Được viết bằng Ruby, Travis CI đang hiện có dưới dạng dịch vụ SaaS.
                ~ Mặc dù họ cung cấp dịch vụ miễn phí để làm việc với các dự án có nguồn mở, nhưng sẽ có một tùy chọn chi phí để sử dụng chúng cho các dự án theo yêu 
                  cầu nếu cần. Nếu bạn chủ yếu làm việc trong môi trường GitHub, thì đây là một lựa chọn tốt để bắt đầu
        + Bitbucket
                ~ Nổi tiếng từ lâu với các dịch vụ Git, Bitbucket nhanh chóng nổi tiếng là một sản phẩm CD cung cấp cho người dùng các tùy chọn on-prem mạnh mẽ.
                ~ Các tính năng như quản lý quyền truy cập, cung cấp cho quản trị viên các điều khiển hữu ích. Để đảm bảo chỉ những người cho phép mới có thể thay đổi
                  mã của bạn. Gần đây, họ cũng đã giới thiệu Pipes, một cách mới giúp dễ dàng tích hợp các dịch vụ của bên thứ 3 vào môi trường Bitbucket của bạn. Và
                  tránh những rắc rối thông thường khi sửa đổi cấu hình API.
        + CloudBees
                ~ Danh sách các công cụ CI/CD pipeline này không thể hoàn thành mà không có tên một trong những công cụ đi đầu của lĩnh vực này.
                ~ Giải pháp CD của CloudBees giúp dễ dàng tích hợp với Kubernetes và Docker. Cung cấp các điều khiển bảo mật và quản trị. Hiện đang có sẵn cho SaaS hoặc 
                  triển khai on-prem. Và có các công cụ cải thiện khả năng hiển thị trên sản phẩm trong quy trình pipeline.
        + Docker
                ~ Về cơ bản công cụ này như container. Công nghệ đã nổi lên trong vài năm qua vì khả năng di chuyển phần mềm liên tục từ môi trường này sang môi trường 
                  thử nghiệm khác. Và giải quyết được hầu hết các vấn đề tương thích mà chúng ta thường gặp phải.
                ~ Với Docker, thật dễ dàng để làm cho hình ảnh mới, nhẹ hoặc chạy chúng để thử nghiệm. Nếu bạn sử dụng Docker, thì công cụ Kubernetes – mã nguồn mở Google 
                  là rất cần thiết để quản lý container của bạn.

* Lợi ích của CI/CD cho doanh nghiệp :

- Giảm rủi ro : Khi bạn phát triển mã của mình thường xuyên hơn nó sẽ giảm rủi ro cho dự án bạn đang thực hiện vì bạn có thể dễ dàng phát hiện lỗi. Thậm chí bạn có 
  thể sửa lỗi dễ dàng hơn. Điều này giúp tăng tốc độ làm việc cũng như sản xuất các thiệt bị trong doanh nghiệp
- Thân thiện với team: Khi bạn có CI được tích hợp với CD, việc chia sẻ code trở nên dễ dàng và dễ thấy hơn. Nó tăng cường sự hợp tác của các thành viên trong 
  nhóm và do đó giao tiếp tốt hợn giữa các team với nhau
- Vòng tuần hoàn làm việc nhanh hơn: Khi việc phát hành code trở nên thường xuyên, khoảng cách giữa code trong sản xuất và code trong phát triển trở nên nhỏ hơn nhiều. 
  Ngay cả một thay đổi nhỏ cũng có thể được đẩy vào sản xuất trong thời gian ngắn và do đó việc lặp lại code nhanh hơn
- Giảm các quá trình thủ công : Vì toàn bộ quá trình được tự động hóa bởi CI/CD, nổ lực thủ công để  tích hợp các công cụ và kiểm tra sẽ giảm và do đó cung cấp một 
  dòng code trơn tru cho các môi trường khác nhau
- Phản hồi nhanh hơn: Việc thiết lập CI/CD không chỉ giúp các developer mà còn giúp ban quản lý quyết định và hành động các thay đổi trong sản xuất. Khi quá trình 
  phát hành trở nên nhanh hơn nhiều, người quản lý sẽ dễ dàng nhìn thấy những thay đổi và đưa ra quyết định kinh doanh nhanh chóng

* Ưu điểm của CI/CD :

- Fast feedback loop(Vòng lặp phản hồi nhanh): Rất cần cho việc thực hiện vòng đời phát triển nhanh chóng. Để nhận được feedback kịp thời, cần có software tiếp cận 
  end user một cách nhanh chóng. Khi được phát triển đúng cách, CI/CD cung cấp platform để đạt được mục tiêu này bằng cách đơn giản hóa việc cập nhật các production 
  deployment. Bằng cách yêu cầu mỗi thay đổi phải trải qua quá trình kiểm tra nghiêm ngặt, CI giúp giảm thiểu rủi ro liên quan đến từng bản dựng và cho phép các teams 
  phát hành những tính năng có giá trị cho khách hàng nhanh chóng và dễ dàng
- Tăng khả năng hiện thị: CI/CD thường được khai triển như pipeline gồm các bước tuần tự, hiện thị cho toàn bộ team. Do đó, mỗi member trong team có thể theo dõi trạng 
  thái của bảng dựng trong hệ thống và xác định bảng dựng nào chịu trách nhiệm cho lỗi thử nghiệm nào. Bằng cách cung cấp thông tin về trạng thái hiện tại của 
  codebase, việc lập kế hoạch cho giải pháp tốt nhất sẽ dễ dàng hơn. Độ minh bạch này trả lời rõ ràng cho câu hỏi,” liệu commit đã phá vỡ bản dựng chưa?”
- Xử lý sự cố đơn giản: Vì mục tiêu của CI là tích hợp và kiểm tra mọi thay đổi được thực hiện với codebase, nên an toàn hơn khi thực hiên các commit nhỏ và sớm hợp 
  nhất chúng vào code repository được chia sẻ. Kết quả là, khi tìm thấy một bug, việc xác định thay đổi nào gây ra vấn đề đó sẽ dễ dàng hơn. Sau đó, tùy thuộc vào 
  mức độ nghiêm trọng của vấn đề, team có thể xóa thay đổi hoặc viết và cam kết sửa lỗi, giảm thời gian giải quyết vấn đề trong production
- Chất lượng software cao: Tự động hóa quá trình dựng và triển khai không chỉ rút ngắn vòng đời phát triển mà còn giúp các team sản xuất software chất lượng cao hơn. 
  Bằng cách đảm bảo rằng mỗi thay đổi được thực hiện tốt và triển khai cho ít nhất mỗi 1 môi trường pre-production các team có thể tự tin đẩy thay đổi vào production. 
  Điều này chỉ có thể khi có phạm vi thử nghiệm tốt của tất cả các cấp của codebase, từ kiểm tra unit đến kiểm tra hệ thống phức tạp hơn.
- Vấn đề tích hợp ít hơn: Vì bộ kiểm tra tự động chạy trên các bảng dựng được tự động với mọi commit, nên có thể sớm nắm bắt và khắc phục hầu hết các sự cố tích hợp. 
  Điều này giúp developers biết sớm về các công việc khác hiện đang được thực hiện có thể ảnh hưởng đến code. Nó đảm bảo code được viết bởi những contributors khác
  nhau kết hợp tốt với nhau ngay từ đầu thay vì để đến khi có tác dụng phụ nào 
- Thêm thời gian tập trung vào development: CI/CD system dựa vào tự động hóa để tạo ra các bảng dựng và di chuyển các thay đổi mới thông qua pipeline. Vì không cần 
  cam thiệp thủ công, nên việc xây dựng và thực nghiệm khong cầm nhiều thời gian riêng của deployment team. Thay vào đó, developers có thể tập trung vào việc thực 
  hiện thay đổi hiểu qua cho codebase, có thể tự tin rằng các automated systems sẽ thông báo cho họ về bất kỳ vấn đề nào.

 



                                
                            




